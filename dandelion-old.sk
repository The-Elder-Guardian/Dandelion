options:
	version: 0.0.3

function dandelion_version() :: string:
	return "{@version}"
	
on load:
	login to "%{dandelion.discord.token}%" with name "Dandelion"
	change status of bot "Dandelion" to online
	mark the bot named "Dandelion" playing "%{dandelion.map.name}%"
	make new command:
		set discord name of command to "map"
		set description of command to "Obtenir la description de la map actuellement en jeu"
	create slash command with bot named "Dandelion"
	
on slash command:
  set {_m} to new message builder
  append "Voici quelques informations sur le serveur :" to builder {_m}
  append "%nl%`•` Nom de la map: %{dandelion.map.name}%" to builder {_m}
  append "%nl%`•` Auteur de la map: %{dandelion.map.author}%" to builder {_m}
  append "%nl%`•` Vue dans l'édition %{dandelion.map.edition}%" to builder {_m}
  append "%nl%`•` Rejoignez-nous sur `map.theelderguardian.fr`" to builder {_m}
  reply with {_m}

on join:
	if {players.online} is not set:
		set {players.online} to 0
	increase {players.online} by 1
	increase {players.ever} by 1

on quit:
	reduce {players.online} by 1
	if {players.online} < 0:
		set {players.online} to 0
	testVoteEnd()

command setDiscordToken <text>:
	executable by: console
	trigger:
		set {dandelion.discord.token} to arg-1
		send "Token du bot Discord défini sur '%arg-1%'" to console
		send "Rechargement du script afin d'appliquer les modifications" to console
		
command setMapName <text>:
	executable by: console
	trigger:
		if command sender is console:
			set {dandelion.map.name} to arg-1
			send "Nom de la map défini sur '%arg-1%'" to console

command setMapAuthor <text>:
	executable by: console
	trigger:
		if command sender is console:
			set {dandelion.map.author} to arg-1
			send "Nom de la map défini sur '%arg-1%'" to console
			
command mapInfo:
	trigger:
		send "&bMap actuelle : &c%{dandelion.map.name}%" to player
		send "&bAuteur : &c%{dandelion.map.author}%" to player
		
command /addmap [<text>] [<text>] [<text>] [<item>] [<text>]:
	permission: map.add
	trigger:
		if arg 1 isn't set :
			send "&c[&6&lMap&c]&rPrécise un nom de map !"
			stop
		if arg 2 isn't set :
			send "&c[&6&lMap&c]&rPrécise un auteur de map !"
			stop
		if arg 3 isn't set :
			send "&c[&6&lMap&c]&rPrécise l'emplacement de la map !"
			stop
		if arg 4 isn't set :
			send "&c[&6&lMap&c]&rPrécise un item pour le menu !"
			stop
		if arg 5 isn't set :
			send "&c[&6&lMap&c]&rPrécise une description !"
			stop
		if {warp.list::%arg 1%} is set:
			send "&c[&6&lMap&c]&rCe nom de map est déja utilisé !"
			stop
		if arg 1 is set :
			if arg 1 contain "_":
				send "&c[&6&lMap&c]Votre nom de map ne peut contenir de ""_""."
				stop
			if arg 2 contain "_":
				send "&c[&6&lMap&c]Votre nom d'auteur de map ne peut contenir de ""_""."
				stop
			if arg 1 contain "_":
				send "&c[&6&lMap&c]Votre description de map ne peut contenir de ""_""."
				stop
			else:
				set {map.list::%arg 1%} to arg 1
				set {map.author::%arg 1%} to arg 2
				set {map.world::%arg 1%} to arg 3
				set {map.items::%arg 1%} to arg 4
				set {map.desc::%arg 1%} to arg 5
				send "&8[&6&lMap&8]La map ""%arg 1 %"" a été ajoutée à la liste des maps."
				
command /suppmap [<text>]:
	permission: map.supp
	trigger:
		if arg 1 isn't set :
			send "&c[&6&lMap&c]&rPrécise un nom de map à supprimer !"
			stop
		if {warp.world::%arg 1%} isn't set :
			send "&c[&6&lMap&c]La map ""%arg 1 %"" n'existe pas . . ."
			stop
		if {warp.world::%arg 1%} is set :
			send "&8[&6&lMap&8]La map ""%arg 1 %"" a été supprimée."
			delete {map.list::%arg 1%}
			delete {map.author::%arg 1%}
			delete {map.world::%arg 1%}
			delete {map.items::%arg 1%}
			delete {map.desc::%arg 1%}

command /suppallmap [<text=false>]:
	permission: warp.supprall
	trigger:
		if arg 1 is "true":
			send "&8[&6&lWarp&8]TOUS les warps ont été supprimé "
			delete {map.list::*}
			delete {map.author::*}
			delete {map.world::*}
			delete {map.items::*}
			delete {map.desc::*}
		else:
			send "&4[&6&lMap&4]&cVeuillez confirmer l'action avec la commande &9/suppallmap true."
			
			
command /map [<player>] [<text=menu>] [<text>]:
	trigger:
		if arg 1 isn't set :
			if {dandelion.vote.started} is not set:
				make player execute command "/map %player% menu"
			if {dandelion.vote.started} is true:
				make player execute command "/map %player% votemenu"
		if arg 1 is set:
			if arg 2 isn't set: 
				make player execute command "/map %player% %arg 1%"
				stop
			if arg 2 is "menu":
				wait 2 ticks
				open chest with 6 rows named "&3&l[&6Maps &3Menu&3&l]" to arg 1 
				wait 1 tick
				set {_slot.map} to 0
				loop {map.list::*}:
					set {_loop} to loop-value
					format slot {_slot.map} of arg 1 with {map.items::%{_loop}%} named "&a&l%{_loop}%" with lore "&3• &bMap &3: &c%{_loop}%", "&3• &bAuteur &3: &c%{map.author::%{_loop}%}%" and "&3• &bDescription &3: &c%{map.desc::%{_loop}%}%" to close then run "map %arg 1% votefor %{_loop}%"
					add 1 to {_slot.map}
				stop
			if arg 2 is "votefor": 
				if {dandelion.vote.started} is not set:
					if {players.online} is not 1:
						if {dandelion.lastvote.%arg 3%} was less than 10 minutes:
							send "&cCette map a été refusée en vote il y a moins de 10 minutes, réessayez plus tard !"
						broadcast "&3%arg 1% &bvient de lancer un vote pour changer de map, il propose la map &3%arg 3% &b!"
						broadcast "&3•&b Utilisez la commande ""/map"" pour accepter ou refuser la demande"
						set {dandelion.lastvote.%arg 3%} to now
						set {dandelion.vote.started} to true
						set {dandelion.vote.active} to arg 3
						set {dandelion.vote.for} to 1
						set {dandelion.vote.against} to 0
						set {dandelion.voted.player::%arg 1%} to true
					if {players.online} is 1:
						broadcast "Yellow"
						make console execute command "/changemap %arg 3%"
				if {dandelion.vote.started}:
					if {dandelion.voted.player::%arg 1%} is true:
						send "&4Désolé&c, vous avez déjà voté durant ce vote !" to arg 1
					else:
						set {dandelion.voted.player::%arg 1%} to true
						add 1 to {dandelion.vote.for}
						testVoteEnd()
			if arg 2 is "votemenu":
				open chest with 4 rows named "&3&l[&6Maps &3Vote&3&l]" to arg 1
				wait 1 tick
				format slot 13 of arg 1 with {map.items::%{dandelion.vote.active}%} named "&a&l%{dandelion.vote.active}%" with lore "&3• &bMap &3: &c%{dandelion.vote.active}%", "&3• &bAuteur &3: &c%{map.author::%{dandelion.vote.active}%}%" and "&3• &bDescription &3: &c%{map.desc::%{dandelion.vote.active}%}%" to be unstealable
				
function testVoteEnd():
	if {players.online} <= {dandelion.vote.for} + {dandelion.vote.against}:
		if {dandelion.vote.for} >= {dandelion.vote.against}:
			broadcast "&bTous les joueurs ont votés ! &3Le vote est terminé &b!"
			broadcast "&cRésultat : &bChangement &aaccepté !"
			make console execute command "/changemap %{dandelion.vote.active}%"
			delete {dandelion.vote.active}
			delete {dandelion.vote.started}
		if {dandelion.vote.for} < {dandelion.vote.against}:
			broadcast "&bTous les joueurs ont votés ! &3Le vote est terminé &b!"
			broadcast "&cRésultat : &bChangement &4refusé !"
			delete {dandelion.vote.active}
			delete {dandelion.vote.started}
			delete {dandelion.voted.player::*} 
